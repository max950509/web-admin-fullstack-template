# 基础架构设计

本模板旨在提供一个稳固、可扩展、易于维护的全栈应用骨架。它不仅仅是技术的堆砌，更是一套经过实践检验的工程化解决方案，旨在让开发者能快速聚焦于业务逻辑，而非重复的基础建设。

## 1. 设计哲学

*   **约定优于配置**: 遵循框架的最佳实践，提供明确的模块组织方式和代码规范，减少不必要的决策成本。
*   **领域驱动设计 (DDD) 的轻量级实践**: 后端按业务领域（如 `auth`, `user`, `role`）划分模块，使得业务边界清晰。
*   **Schema 驱动 UI**: 前端通过统一的数据结构（Schema）来驱动列表、表单和详情页的渲染，极大地减少了重复的 UI 代码。
*   **基础设施即代码 (IaC)**: 使用 Docker Compose 和 Nginx 配置文件来定义和管理整个应用的运行环境，确保开发、测试和生产环境的一致性。
*   **可观测性优先**: 从第一天起就将可观测性视为核心功能，而非事后补充。

## 2. 整体架构图

下图展示了系统的主要组件及其交互关系：

```
+-----------------+      +------------------+      +-----------------+
|     Browser     |----->|      Nginx       |----->|  Frontend (React)|
+-----------------+      |(Reverse Proxy)   |      +-----------------+
                         +------------------+
                                  |
                                  | /api
                                  v
+-----------------+      +------------------+      +-----------------+
| Backend (NestJS)|<---->|      Redis       |<---->|   BullMQ Worker |
+-----------------+      |(Cache, Session,  |      +-----------------+
       |                 |      Queue)      |
       |                 +------------------+
       | (Prisma)
       v
+-----------------+
| PostgreSQL DB   |
+-----------------+

       |--------------------------------------> OpenTelemetry Collector -----> Prometheus / Tempo / Grafana
```

**交互流程**:

1.  用户的浏览器访问应用，请求首先到达 **Nginx**。
2.  Nginx 作为反向代理，静态资源由它处理，API 请求（`/api`）被转发到 **后端 NestJS 服务**。
3.  后端服务处理业务逻辑，通过 **Prisma** ORM 与 **PostgreSQL** 数据库交互。
4.  **Redis** 在系统中扮演多重角色：
    *   缓存常用数据。
    *   存储用户登录的 Token 和会话信息。
    *   作为 **BullMQ** 的消息队列，驱动异步任务（如导出）。
5.  对于耗时操作，后端会向 BullMQ 队列中添加一个任务，由一个独立的 **Worker 进程** 消费并执行。
6.  在整个过程中，后端服务持续产生遥测数据（Metrics, Traces），并发送给 **OpenTelemetry Collector** 进行处理和分发。

## 3. 后端架构

后端基于 **NestJS** 框架，它提供了一套强大的、基于 TypeScript 的面向对象编程范式。

*   **模块化 (`@Module`)**: 应用被拆分为多个业务模块（`UserModule`, `RoleModule` 等）。每个模块都封装了自己的 `Controller`, `Service`, 和 `DTO`，实现了高度的内聚和低耦合。
*   **依赖注入**: NestJS 内置的依赖注入系统被广泛使用，使得代码更易于测试和维护。
*   **核心全局模块**:
    *   **Guards (`TokenAuthGuard`, `PermissionsGuard`)**: 负责请求的认证（用户是否登录）和授权（用户是否有权执行操作），是安全体系的核心。
    *   **Interceptors (`OperationLogInterceptor`)**: 用于横切关注点，例如自动记录所有成功的变更操作到审计日志。
    *   **Pipes (`ValidationPipe`)**: 在请求到达 Controller 之前，自动对传入的数据（DTO）进行验证和转换。
*   **数据访问层**:
    *   **Prisma**: 我们选择 Prisma 作为 ORM。它通过 `schema.prisma` 文件定义数据模型，并能生成完全类型安全的客户端，极大地提升了数据库操作的可靠性和开发体验。数据库的变更通过 Prisma Migrate 进行版本化管理。

## 4. 前端架构

前端是一个基于 **Vite** 构建的 **React 18** 单页应用 (SPA)。

*   **组件库**: **Ant Design** 和 **Ant Design Pro Components** 提供了高质量、开箱即用的 UI 组件，是快速构建后台界面的基石。
*   **Schema 驱动 UI**: 这是前端架构的核心思想。我们不为每个页面的表格、表单和详情页单独编写 JSX，而是定义一套统一的 `columns` Schema。
    *   `BaseProTable` 等基础组件会消费这套 Schema，自动渲染出对应的 UI。
    *   通过 `patchSchema` 函数可以对基础 Schema 进行微调，以适应不同场景（例如，创建表单时需要密码字段，而编辑时则不需要）。
    *   这种模式使得代码量大幅减少，且保证了同类页面的 UI 一致性。
*   **路由与状态管理**:
    *   **React Router**: 用于管理应用的路由。我们在路由配置中加入了自定义的 `handle` 字段，用于附加权限码、缓存配置等元数据。
    *   **React Activation**: 配合 `TabsContext`，实现了多标签页的 `KeepAlive` 功能，保留了页面的滚动位置和组件状态，提升了用户体验。
*   **请求封装**: 使用 `axios` 进行请求封装，统一处理了请求头、Token 注入、响应拦截和错误处理。

## 5. 部署架构

*   **Docker Compose**: 作为容器编排工具，`deploy/docker-compose.yml` 文件定义了应用的所有服务、网络、数据卷和依赖关系。
*   **多阶段构建**: `Dockerfile` 采用了多阶段构建技术。例如，后端镜像的构建分为 `builder`, `migrate`, `seed`, `runner` 等多个阶段，最终只将运行所需的最小文件集打包到生产镜像中，极大地减小了镜像体积。
*   **Nginx**: 在生产环境中，Nginx 作为前端的 Web 服务器和后端的反向代理，提供了静态内容服务、负载均衡和安全防护。

