# 权限与鉴权设计 (RBAC)

本项目的权限系统是其核心功能之一，采用业界成熟的 **RBAC (Role-Based Access Control)** 模型。它以“动作+资源”作为最小授权单元，实现了灵活、可扩展且易于维护的权限管理体系。

## 1. 核心概念与模型

权限系统的三个核心实体是 **用户 (User)**、**角色 (Role)** 和 **权限 (Permission)**。

*   **用户 (User)**: 系统操作的实体，即系统中的账号。
*   **角色 (Role)**: 一组权限的集合。例如，“管理员”、“内容运营”、“财务”等都是角色。
*   **权限 (Permission)**: 一个具体的操作许可。例如，“查看用户列表”、“创建文章”、“导出报表”等。

它们之间的关系是：一个用户可以拥有一个或多个角色，一个角色可以包含一条或多条权限。通过将权限分配给角色，再将角色分配给用户，我们实现了用户与权限的解耦，极大地简化了权限管理。

### 数据模型关系 (E-R 图)

```
+-------+       +------------+       +------+       +----------------+       +------------+
| users |-------| user_roles |-------| roles|-------| role_permissions |-------| permissions|
+-------+       +------------+       +------+       +----------------+       +------------+
| id    |       | userId     |       | id   |       | roleId         |       | id         |
| name  |       | roleId     |       | name |       | permissionId   |       | action     |
| ...   |       +------------+       | ...  |       +----------------+       | resource   |
+-------+                            +------+                                | type       |
                                                                             | ...        |
                                                                             +------------+
```

## 2. `Permission` 模型的详细设计

`Permission` 是权限控制的原子。我们对其进行了结构化设计，使其能同时满足前后端的需求。

*   **`action` (动作)**: 定义了对资源能做什么操作。我们约定了一组标准动作：
    *   `create`: 新增
    *   `read`: 读取/查看
    *   `update`: 更新
    *   `delete`: 删除
    *   `export`: 导出
    *   `import`: 导入
    *   `menu`: 特殊动作，表示这是一个菜单项，用于前端动态生成菜单。
*   **`resource` (资源)**: 定义了操作的对象，通常是后端的一个业务实体或前端的一个页面。例如 `user`, `role`, `article`, `dashboard` 等。
*   **`type` (类型)**: 用于在前端 UI 中区分权限的展示和用途。
    *   `menu`: 目录或菜单。它在权限树中作为父节点，本身不代表具体操作，仅用于组织结构。
    *   `page`: 页面访问权限。如果用户没有某个页面的 `read` 权限，该页面在菜单中将不可见。
    *   `action`: 页面内的操作权限，通常对应一个按钮或一个功能点（如“新增用户”按钮）。
*   **`code` (权限码)**: 为了方便前后端交互，我们将 `action` 和 `resource` 组合成一个唯一的字符串，格式为 `action:resource`，例如 `create:user`, `read:role`。

## 3. 后端鉴权流程

后端的鉴权流程由一系列的 **Guard** 来保证，它们像一道道门禁，确保每个请求都是合法且经过授权的。

1.  **认证阶段 (`TokenAuthGuard`)**:
    *   所有需要登录的接口都会应用此 Guard。
    *   它会从请求头中解析 `Authorization` 字段，获取 `access_token`。
    *   在 Redis 中验证 `access_token` 的有效性，并获取关联的用户信息（如 `userId`, `roles`）。
    *   如果 Token 无效或已过期，请求将被拒绝 (401 Unauthorized)。
    *   如果验证通过，它会将用户信息附加到请求对象上（`req.user`），供后续流程使用。

2.  **授权阶段 (`PermissionsGuard`)**:
    *   在需要特定权限的 Controller 方法上，我们使用 `@CheckPermissions('action:resource')` 装饰器来声明所需的权限码。
    *   `PermissionsGuard` 会在请求进入方法体之前被触发。
    *   它会读取该方法所需的权限码（例如 `create:user`）。
    *   然后，它会检查 `req.user` 中包含的角色列表，并查询这些角色是否拥有 `create:user` 这条权限。
    *   如果用户拥有所需权限，请求被放行。
    *   如果用户不具备权限，请求将被拒绝 (403 Forbidden)。

### `admin` 角色的特殊处理

在 `PermissionsGuard` 的逻辑中，有一个特殊的判断：如果当前用户的角色列表中包含 `admin`，则 **跳过所有权限检查**，直接放行。这赋予了 `admin` 角色超级管理员的权限。

```typescript
// PermissionsGuard 伪代码
async canActivate(context: ExecutionContext): Promise<boolean> {
  const requiredPermissions = this.reflector.get<string[]>('permissions', context.getHandler());
  if (!requiredPermissions) {
    return true; // 如果接口没有声明权限，则默认允许访问
  }

  const { user } = context.switchToHttp().getRequest();
  if (user.roles.includes('admin')) {
    return true; // 如果是 admin 角色，直接放行
  }

  const userPermissions = await this.permissionService.getPermissionsForUser(user.id);
  return requiredPermissions.every(p => userPermissions.includes(p));
}
```

## 4. 前端权限控制

前端的权限控制旨在提供与后端一致的用户体验，即“用户看不到自己无权操作的功能”。

1.  **动态路由和菜单**:
    *   用户登录后，后端会返回该用户拥有的所有 `Permission` 列表。
    *   前端的路由模块会根据这份权限列表，递归地过滤 `routes.tsx` 中定义的全量路由表。
    *   只有 `handle.code` 字段存在于用户权限列表中的路由，才会被注册到 `react-router` 中。
    *   侧边栏菜单也是基于这份过滤后的路由表动态生成的，确保用户不会看到自己无权访问的菜单项。

2.  **页面内操作控制**:
    *   对于页面内的按钮（如“新增”、“编辑”、“删除”），我们同样使用权限码进行控制。
    *   提供一个 `usePermissions` Hook，可以方便地检查当前用户是否拥有某个操作的权限。

    ```tsx
    // 示例：在页面组件中使用
    import { usePermissions } from '@/hooks/usePermissions';

    const UserPage = () => {
      const { hasPermission } = usePermissions();

      return (
        <div>
          {hasPermission('create:user') && <Button>新增用户</Button>}
          {hasPermission('export:user') && <Button>导出用户</Button>}
          <UserTable />
        </div>
      );
    };
    ```

通过这种方式，我们实现了从路由、菜单到页面按钮的全方位、数据驱动的权限控制。

