# 登录与认证机制

本项目的登录与认证体系在保障安全性的前提下，提供了灵活的扩展能力，支持验证码、两步验证（2FA/OTP）和精细化的会话管理。

## 1. 核心设计原则

*   **安全优先**: 密码绝不以明文存储；验证码一次性有效，防止重放攻击；会话可被主动管理和失效。
*   **状态分离**: 认证状态（Token）存储在 Redis 中，而非直接使用无状态的 JWT。这使得服务端可以主动管理会话，例如实现“强制下线”功能。
*   **流程原子性**: 将普通登录和两步验证（2FA）流程解耦。用户必须先通过第一步验证，才能获得一个临时的、作用域受限的 `2fa` Token，用于进行第二步验证。

## 2. 登录流程详解

```
+-----------+        +----------------------+        +-------------------+
|   用户     |------->|  GET /auth/captcha   |------->|  生成验证码 & 存Redis |
+-----------+        +----------------------+        +-------------------+
     |
     | (提交账号, 密码, 验证码)
     v
+----------------------------------------------------------------+
| POST /auth/login                                               |
| 1. CaptchaGuard: 校验验证码 (成功后立即失效)                      |
| 2. AuthService: 校验账号密码 (bcrypt.compare)                    |
| 3. 检查用户是否绑定 2FA                                         |
+----------------------------------------------------------------+
     |                                       |
 (未绑定 2FA)                             (已绑定 2FA)
     |                                       |
     v                                       v
+---------------------------------+        +--------------------------------------+
| 生成 access_token (scope=access) |        | 生成临时的 2fa_token (scope=2fa)        |
| 存入 Redis 并返回给用户          |        | 存入 Redis 并返回给用户               |
+---------------------------------+        +--------------------------------------+
     |                                       |
     | (登录成功)                             | (提交 2fa_token 和 OTP 动态码)
     |                                       v
     |                               +------------------------------------------+
     |                               | POST /auth/login/2fa                     |
     |                               | 1. TokenAuthGuard: 校验 2fa_token        |
     |                               | 2. AuthService: 校验 OTP 动态码          |
     |                               +------------------------------------------+
     |                                       |
     |                                       v
     |                               +---------------------------------+
     |                               | 生成 access_token (scope=access) |
     |                               | 存入 Redis 并替换旧 token        |
     |                               +---------------------------------+
     |                                       |
     +---------------------------------------+
                                             |
                                             v
                                     +---------------+
                                     |   登录成功     |
                                     +---------------+
```

## 3. Token 策略与会话管理

我们不使用传统的无状态 JWT，而是将 Token 作为一个指向 Redis 中会话数据的 key。这种“有状态 Token”的设计提供了强大的会话管理能力。

### Redis 中的 Token 结构

当用户登录成功后，我们会在 Redis 中创建一个 key（例如 `token:userId:uuid`），其 value 是一个包含以下信息的 Hash：

*   `userId`: 用户 ID
*   `username`: 用户名
*   `roles`: 用户的角色列表
*   `scope`: Token 的作用域，`access` 表示完全访问权限，`2fa` 表示仅用于两步验证。
*   `ver`: **会话版本号**。该值与 `users` 表中的 `sessionVersion` 字段对应。
*   `issuedAt`: 签发时间
*   `lastRenewAt`: 最近一次续期时间

### `TokenAuthGuard` 的校验逻辑

当用户携带 `access_token` 访问受保护的接口时，`TokenAuthGuard` 会执行以下操作：

1.  从 Redis 中查找该 Token。如果不存在，则认证失败。
2.  获取 Token 对应的 `userId` 和 `ver`。
3.  从数据库或缓存中查询该用户的当前 `sessionVersion`。
4.  **比较 `ver` 和 `sessionVersion`**。如果两者不一致，意味着该用户的会话已被管理员重置，当前 Token 失效，认证失败。
5.  如果一致，则认证通过，并将用户信息附加到请求对象。

### 会话的续期与失效

*   **滑动续期**: 在 `TokenAuthGuard` 中，如果一个有效的 Token 即将过期（例如，生命周期已过半），我们会为其重新设置过期时间，实现“用户持续活跃则不掉线”的效果。
*   **最大生命周期**: Token 即使不断续期，也有一个最长的总生命周期（例如 7 天），到期后必须重新登录。
*   **主动退出 (`/auth/logout`)**: 用户主动退出时，会从 Redis 中删除当前的 Token。
*   **强制全部下线 (`/auth/logout-all`)**: 管理员或用户本人可以调用此接口，它会使该用户 **所有设备** 上的 Token 全部失效。其原理是：
    1.  递增 `users` 表中该用户的 `sessionVersion` 字段。
    2.  此时，该用户持有的所有旧 Token 中的 `ver` 值，都将小于数据库中新的 `sessionVersion` 值。
    3.  根据 `TokenAuthGuard` 的校验逻辑，所有旧 Token 在下一次使用时都会认证失败，从而实现强制下线。

## 4. 安全性考量

*   **密码存储**: 用户密码在存入数据库前，会使用 `bcrypt` 库进行加盐哈希，确保即使数据库泄露，也无法直接获取用户密码。密码比对时，使用 `bcrypt.compare` 方法进行安全比较。
*   **验证码**:
    *   使用 `svg-captcha` 在后端生成，避免前端可预测。
    *   验证码文本存储在 Redis 中，并设置较短的过期时间（如 5 分钟）。
    *   `CaptchaGuard` 在校验验证码后会立即将其从 Redis 中删除，确保每个验证码只能使用一次，有效防止暴力破解和重放攻击。
*   **2FA/OTP**:
    *   使用 `otplib` 库，遵循 TOTP (Time-Based One-Time Password) 标准算法。
    *   用户的 `otpSecret` 密钥经过加密后存储在数据库中。

