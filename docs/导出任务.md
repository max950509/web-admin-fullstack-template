# 异步导出任务设计

在后台管理系统中，数据导出是一个常见但又充满挑战的功能。当数据量巨大时，同步导出不仅会造成请求超时，还会长时间占用服务器资源，严重影响用户体验。为了解决这个问题，本项目设计了一套基于 **BullMQ** 和 **Redis** 的通用异步任务系统，并将“导出”作为其第一个应用场景。

## 1. 设计目标

*   **非阻塞**: 用户点击导出后，立即返回响应，无需等待文件生成。
*   **状态可追溯**: 用户可以在“导出任务”页面查看自己所有任务的实时状态（排队中、处理中、已完成、失败）。
*   **结果可下载**: 任务成功后，用户可以直接下载生成的 Excel 或 CSV 文件。
*   **高可扩展性**: 框架必须易于扩展，添加一个新的导出类型（如“导出角色列表”）应尽可能简单，无需改动核心逻辑。

## 2. 核心依赖与架构

*   **BullMQ**: 一个基于 Redis 的、功能强大且性能优秀的 Node.js 任务队列库。
*   **Redis**: 作为 BullMQ 的后端，负责任务的存储、排队和状态管理。我们复用了项目中已有的 Redis 连接。
*   **NestJS `@nestjs/bullmq`**: 提供了与 NestJS 框架的无缝集成。

**架构图**:

```
+-----------------+      +----------------------+      +-----------------+
|  用户发起导出请求  |----->| ExportTaskController |----->| ExportTaskService |
| (POST /export-tasks)|    | (创建任务接口)        |      | (创建任务记录)     |
+-----------------+      +----------------------+      +--------+--------+
                                                                 |
                                                                 v
+----------------------------------------------------------------+
| 1. 在数据库中创建一条 ExportTask 记录 (status='pending')         |
| 2. 向 BullMQ 的 'export-task' 队列中添加一个 Job                  |
|    (Job data 包含新创建的 taskId)                                |
+----------------------------------------------------------------+
       |
       | (立即返回 taskId 给用户)
       v
+-----------------+
|   用户得到响应    |
+-----------------+


+-----------------+      +----------------------+      +-----------------+
| BullMQ Worker   |----->|  消费 'export-task'  |----->| ExportTaskProcessor|
| (独立进程)       |      |        队列          |      | (处理 Job)       |
+-----------------+      +----------------------+      +--------+--------+
                                                                 |
                                                                 v
+----------------------------------------------------------------+
| 1. 从 Job data 中获取 taskId                                     |
| 2. 更新数据库中任务状态为 'running'                               |
| 3. 调用 ExportTaskService.getHandler(task.type) 获取对应的处理器 |
| 4. 执行 handler.export() 生成文件                                |
| 5. 更新任务状态为 'completed' 或 'failed'，并保存文件路径          |
+----------------------------------------------------------------+
```

## 3. 任务生命周期与状态机

一个导出任务会经历以下几种状态：

*   `pending`: 任务已创建，正在队列中等待 Worker 处理。
*   `running`: Worker 已接收该任务，正在生成文件。
*   `completed`: 文件生成成功。
*   `failed`: 文件生成过程中发生错误。

```
[pending] --(Worker 接收)--> [running] --(生成成功)--> [completed]
   |                             |
   |                             +----(生成失败)--> [failed]
   +----(长时间未处理)--> [stalled] (BullMQ 内置状态)
```

## 4. 数据模型 (`ExportTask`)

`ExportTask` 表是任务系统的核心，记录了每一次导出的所有信息。

*   `id`: 任务的唯一标识。
*   `type`: **任务类型**。这是一个关键字段，用于动态路由到不同的处理逻辑。例如 `account` 表示账号导出，`role` 表示角色导出。
*   `status`: 任务的当前状态 (`pending`, `running`, `completed`, `failed`)。
*   `format`: 导出的文件格式 (`xlsx`, `csv`)。
*   `params`: **查询参数**。一个 JSON 字段，存储了用户发起导出时附带的所有查询条件（如搜索关键词、筛选状态等）。Worker 会使用这些参数来查询需要导出的数据。
*   `fileName` / `filePath`: 任务成功后，生成的文件的名称和存储路径。
*   `error`: 如果任务失败，这里会记录错误信息。
*   `createdById`: 发起任务的用户 ID。

## 5. 代码实现详解

### 5.1. 动态处理器 (`Handler`)

为了实现可扩展性，我们定义了一个 `IExportHandler` 接口，所有具体的导出逻辑都必须实现这个接口。

```typescript
// export-task.interface.ts
interface IExportHandler {
  export(task: ExportTask): Promise<{ fileName: string; filePath: string }>;
}
```

### 5.2. 处理器分发

`ExportTaskService` 中有一个 `getHandler` 方法，它像一个工厂，根据任务的 `type` 返回对应的处理器实例。

```typescript
// export-task.service.ts
@Injectable()
export class ExportTaskService {
  constructor(private readonly accountExportHandler: AccountExportHandler) {}

  getHandler(type: string): IExportHandler {
    switch (type) {
      case 'account':
        return this.accountExportHandler;
      // case 'role':
      //   return this.roleExportHandler; // 扩展点
      default:
        throw new Error(`No handler found for export type: ${type}`);
    }
  }
}
```

### 5.3. Worker 处理器 (`ExportTaskProcessor`)

这个类负责消费 BullMQ 队列中的任务，并执行核心处理逻辑。

```typescript
// export-task.processor.ts
@Processor('export-task')
export class ExportTaskProcessor extends WorkerHost {
  async process(job: Job<any, any, string>): Promise<any> {
    const taskId = job.data.taskId;
    
    // 1. 更新状态为 running
    await this.prisma.exportTask.update({ where: { id: taskId }, data: { status: 'running' } });

    try {
      const task = await this.prisma.exportTask.findUnique({ where: { id: taskId } });
      
      // 2. 获取动态处理器
      const handler = this.exportTaskService.getHandler(task.type);
      
      // 3. 执行导出
      const { fileName, filePath } = await handler.export(task);

      // 4. 更新状态为 completed
      await this.prisma.exportTask.update({
        where: { id: taskId },
        data: { status: 'completed', fileName, filePath },
      });
    } catch (error) {
      // 5. 更新状态为 failed
      await this.prisma.exportTask.update({
        where: { id: taskId },
        data: { status: 'failed', error: error.message },
      });
    }
  }
}
```

## 6. 如何扩展新的导出类型

假设我们需要添加一个“导出角色列表”的功能，只需遵循以下步骤：

1.  **创建 Handler**: 新建一个 `src/modules/export-task/handlers/role-export.handler.ts` 文件，并实现 `IExportHandler` 接口。在 `export` 方法中编写查询和生成角色列表文件的逻辑。
2.  **注册 Handler**: 在 `ExportTaskModule` 中 `provide` 新的 Handler，并在 `ExportTaskService` 的 `getHandler` 方法中添加一个新的 `case` 分支。
3.  **定义任务类型**: 在前端和后端定义一个新的 `type`，例如 `role`。
4.  **添加前端入口**: 在角色管理页面添加一个“导出”按钮，点击后调用 `POST /export-tasks` 接口，并传递 `type: 'role'` 以及其他必要的筛选参数。

通过以上步骤，一个新的导出功能就无缝地集成到了现有的异步任务体系中。

